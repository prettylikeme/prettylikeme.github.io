<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<title>
  
    Tag: COM 组件
  
</title>

<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/tags/COM-%E7%BB%84%E4%BB%B6/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Yang">
<meta name="twitter:card" content="summary">


  <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">





  <link rel="icon" href="/favicon.png">



<link rel="stylesheet" href="/perfect-scrollbar/css/perfect-scrollbar.min.css">


<link rel="stylesheet" href="/styles/main.css">







<meta name="generator" content="Hexo 5.2.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"] > svg a {
  fill: blue;
  stroke: blue;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head>
<body
  
    class="monochrome"
  
  >
  <div class="mobile-header">
  <button class="sidebar-toggle" type="button">
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
  </button>
  <a class="title" href="/">Hexo</a>
</div>

  <div class="main-container">
    <div class="sidebar">
  <div class="header">
    <h1 class="title"><a href="/">Hexo</a></h1>
    
    <div class="info">
      <div class="content">
        
        
          <div class="author">Yang</div>
        
      </div>
      
        <div class="avatar">
          
            <a href="/about"><img src="https://cn.gravatar.com/avatar/35fef74d731255cd569c2c2b0b9e87e4?s=200"></a>
          
        </div>
      
    </div>
  </div>
  <div class="body">
    
      
        <ul class="nav">
          
            
              <li>
                <a href="/" title="主页" external="false">主页</a>
              </li>
            
          
        </ul>
      
        <ul class="nav">
          
            
              <li class="category-list-container">
                <a href="javascript:;">分类</a>
                <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C++</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Html/">Html</a><span class="category-list-count">30</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Html/JavaScript/">JavaScript</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Html/JavaScript/ES6/">ES6</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Html/Vue/">Vue</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Math/">Math</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Qt/">Qt</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a><span class="category-list-count">17</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">正则表达式</a><span class="category-list-count">1</span></li></ul>
              </li>
            
          
            
              <li class="tag-list-container">
                <a href="javascript:;">标签</a>
                <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/" rel="tag">Android</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android-Studio/" rel="tag">Android Studio</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C++</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-11/" rel="tag">C++ 11</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/COM-%E7%BB%84%E4%BB%B6/" rel="tag">COM 组件</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/" rel="tag">CSS</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Chrome/" rel="tag">Chrome</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Chrome-%E6%8F%92%E4%BB%B6/" rel="tag">Chrome 插件</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DirextX/" rel="tag">DirextX</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DirextX-12/" rel="tag">DirextX 12</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ES5/" rel="tag">ES5</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ES6/" rel="tag">ES6</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/" rel="tag">Git</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Html/" rel="tag">Html</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IntelliJ-Idea/" rel="tag">IntelliJ Idea</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Math/" rel="tag">Math</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-js/" rel="tag">Node.js</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Parcel/" rel="tag">Parcel</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Promise/" rel="tag">Promise</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Proxy/" rel="tag">Proxy</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Qt/" rel="tag">Qt</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SVG/" rel="tag">SVG</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Scoop/" rel="tag">Scoop</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sublime-Text-3/" rel="tag">Sublime Text 3</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Symbol/" rel="tag">Symbol</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TypeScript/" rel="tag">TypeScript</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VSCode/" rel="tag">VSCode</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue-Router/" rel="tag">Vue Router</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue-js/" rel="tag">Vue.js</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue%E6%BA%90%E7%A0%81/" rel="tag">Vue源码</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Webpack/" rel="tag">Webpack</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Win32-%E5%BC%80%E5%8F%91/" rel="tag">Win32 开发</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/awk/" rel="tag">awk</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bat/" rel="tag">bat</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cmd/" rel="tag">cmd</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/grep/" rel="tag">grep</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jQuery/" rel="tag">jQuery</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vector/" rel="tag">vector</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/xarg/" rel="tag">xarg</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%9F%E7%90%86/" rel="tag">原理</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%91%BD%E4%BB%A4/" rel="tag">命令</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%97%E4%BD%93/" rel="tag">字体</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7/" rel="tag">工具</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/" rel="tag">打包工具</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8F%92%E4%BB%B6/" rel="tag">插件</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/" rel="tag">插件开发</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" rel="tag">正则表达式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B3%A8%E5%86%8C%E8%A1%A8/" rel="tag">注册表</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/" rel="tag">游戏开发</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%94%B5%E8%84%91%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/" rel="tag">电脑性能测试</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A0%B4%E8%A7%A3/" rel="tag">破解</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E7%BD%AE/" rel="tag">设置</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6/" rel="tag">软件</a><span class="tag-list-count">6</span></li></ul>
              </li>
            
          
            
              <li class="archive-list-container">
                <a href="javascript:;">归档</a>
                <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/">2019</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/">2018</a><span class="archive-list-count">48</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/">2017</a><span class="archive-list-count">7</span></li></ul>
              </li>
            
          
        </ul>
      
    
  </div>
</div>

    <div class="main-content">
      
        <div style="max-width: 1000px">
      
          <h1>COM 组件</h1>


  
  
    <div class="post-list">
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/2017/05/12/%E5%BC%80%E5%8F%91/C++/COM%E7%BB%84%E4%BB%B6/" >
  COM 组件
</a>

      </h3>
      

      <div class="article-info">
        <a href="/2017/05/12/%E5%BC%80%E5%8F%91/C++/COM%E7%BB%84%E4%BB%B6/"><span class="article-date">
  2017-05-12
</span>
</a>
        
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/C/">C++</a></li></ul>
	</span>


        
	<span class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/COM-%E7%BB%84%E4%BB%B6/" rel="tag">COM 组件</a></li></ul>
	</span>


      </div>
      <div class="article-entry">
        
          <h2 id="COM"><a href="#COM" class="headerlink" title="COM"></a>COM</h2><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.vckbase.com/index.php/wv/144">COM编程入门</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/guyue6670/article/details/2243781">C++中COM调用方法</a></li>
<li><a target="_blank" rel="noopener" href="http://www.ccidnet.com/2002/1111/30384.shtml">WTL框架窗口分析</a></li>
<li><a target="_blank" rel="noopener" href="http://andylin02.iteye.com/blog/453079">ATL入门：利用ATL编写简单的COM组件</a></li>
</ul>
</blockquote>
<hr>
<h2 id="组件的创建"><a href="#组件的创建" class="headerlink" title="组件的创建"></a>组件的创建</h2><ol>
<li>实现 <code>IClassFactory</code> 或 <code>IClassFactory2</code> 接口；</li>
<li>实现 <code>DllGetClassObject</code> 函数；</li>
</ol>
<hr>
<h2 id="定义一个COM接口"><a href="#定义一个COM接口" class="headerlink" title="定义一个COM接口"></a>定义一个COM接口</h2><p>定义COM接口时应包含&lt;*ObjBase.h*&gt;头文件：<br>该头文件中包含 <code>interface</code> 宏</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> interface struct</span></span><br></pre></td></tr></table></figure>

<p>在上述定义中使用 <code>struct</code> 的原因在于 <code>struct</code> 的成员将自动具有公有的属性。</p>
<ul>
<li>COM接口在C++中是用纯抽象基类实现的。</li>
<li>一个COM组件可以支持多个接口。</li>
<li>一个C++类可以使用多继承来实现一个支持多个接口的组件。</li>
</ul>
<p>如下例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ObjBase.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">Interface IX</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> __stdcall <span class="title">Fx1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> __stdcall <span class="title">Fx2</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>__stdcall或Pascal调用约定</strong></p>
<p>用 <code>__stdcall</code> 标记的函数将使用PASCAL调用约定，即这些函数将在返回到调用者之前将参数从栈中删除。<br>Windows采用PASCAL调用约定的原因在于这种约定可以减少代码的大小，另外还有一个原因是早期的Windows是运行于640KB的系统上的。<br>带有变参（参数数目可变）的函数仍然使用C调用约定，即 <code>__cdecl</code> 。</p>
<p>在&lt;*Windef.h*&gt;中，pascal的定义如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pascal __stdcall</span></span><br></pre></td></tr></table></figure>

<p>也可以使用&lt;*ObjBase.h*&gt;中所定义的如下宏：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STDMETHODCALLTYPE __stdcall</span></span><br></pre></td></tr></table></figure>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th>虚函数表</th>
</tr>
</thead>
<tbody><tr>
<td>pIX</td>
<td>=&gt;</td>
<td>vtbl指针</td>
<td>=&gt;</td>
<td>&amp;Fx1</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td>&amp;Fx2</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td>&amp;Fx3</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td>&amp;Fx4</td>
</tr>
</tbody></table>
<p>纯抽象基类只有纯虚函数，而没有任何实例数据。</p>
<p>所有的COM接口都必须继承一个名为 <code>IUnknown</code> 的接口<br>该接口的定义包含在&lt;*UNKNWN.h*&gt;头文件中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface IUnknown</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> HRESULT __stdcall <span class="title">QueryInterface</span><span class="params">(<span class="keyword">const</span> IID&amp; iid, <span class="keyword">void</span> ** ppv)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function">vitrual ULONG __stdcall <span class="title">AddRef</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ULONG __stdcall <span class="title">Release</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义一个接口：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface IX : IUnknown</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="QueryInterface"><a href="#QueryInterface" class="headerlink" title="QueryInterface"></a>QueryInterface</h3><p>客户可以通过此函数来查询某个组件是否支持某个特定的接口。<br>若支持，则 <code>QueryInterface</code> 将返回一个指向此接口的指针；否则返回值将是一个错误代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HRESULT __stdcall <span class="title">QueryInterface</span><span class="params">(<span class="keyword">const</span> IID&amp; iid, <span class="keyword">void</span> **ppv)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中的第一个参数标识了客户所需的接口，此参数是一个“接口标识符”（IID）结构。<br>另外一个参数用来存放所请求接口指针的地址。<br><code>QueryInterface</code> 返回的是一个HRESULT值，此值实际上并不像其名称所表示的那样是标识某个结果的句柄；相反，它是一个具有特定格式的32位值。<br><code>QueryInterface</code> 可以返回 <code>S_OK</code> 或 <code>E_NOINTERFACE</code> ，客户不应将其返回值直接同这两个值进行比较，而应使用SUCCEEDED宏或FAILED宏。</p>
<ul>
<li><p><strong>QueryInterface的使用</strong></p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(IUnknown* pI)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Define a pointer for the interface.</span></span><br><span class="line">    IX* pIX = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ask for interface IX.</span></span><br><span class="line">    HRESULT hr = pI-&gt;QueryInterface(IID_IX, (<span class="keyword">void</span>**)&amp;pIX);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check return value.</span></span><br><span class="line">    <span class="keyword">if</span> (SUCCEEDED(hr))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Use interface.</span></span><br><span class="line">        pIX-&gt;Fx();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong>：在调用 <code>QueryInterface</code> 之前，我们将pIX初始化为NULL，这是一种比较好的编程习惯。由于 <code>QueryInterface</code> 是由程序员而不是系统实现的，因此某些组件可能并不会在查询失败时将此指针置为NULL。因此为安全起见，在程序中还是我们自己将其置为NULL比较好。</p>
</blockquote>
</li>
<li><p><strong>QueryInterface的实现</strong>  </p>
<p>若组件支持客户指定的接口，那么应返回 <code>S_OK</code> 以及相应的指针；若不支持，返回应是 <code>E_NOINTERFACE</code> ，并将相应的指针返回值置成NULL。</p>
<p>如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">interface IX : IUnKnown &#123;<span class="comment">/*...*/</span>&#125;;  </span><br><span class="line">interface IY : IUnKnown &#123;<span class="comment">/*...*/</span>&#125;;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CA</span> :</span> <span class="keyword">public</span> IX, <span class="keyword">public</span> IY &#123;<span class="comment">/*...*/</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">HRESULT __stdcall <span class="title">CA::QueryInterface</span><span class="params">(<span class="keyword">const</span> IID&amp; iid, <span class="keyword">void</span>** ppv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (iid == IID_IUnknown)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// The client wants the IUnknown interface.</span></span><br><span class="line">        *ppv = <span class="keyword">static_cast</span>&lt;IX*&gt;(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (iid == IID_IX)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// The client wants the IX interface.</span></span><br><span class="line">        *ppv = <span class="keyword">static_cast</span>&lt;IX*&gt;(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (iid == IID_IY)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// The client wants the IY interface.</span></span><br><span class="line">        *ppv = <span class="keyword">static_cast</span>&lt;IY*&gt;(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// We don&#x27;t support the interface the client</span></span><br><span class="line">        <span class="comment">// wants. Be sure to set the resulting pointer</span></span><br><span class="line">        <span class="comment">// to NULL.</span></span><br><span class="line">        *ppv = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> E_NOINTERFACE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static_cast</span>&lt;IUnknown*&gt;(*ppv)-&gt;AddRef();</span><br><span class="line">    <span class="keyword">return</span> S_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>QueryInterface返回的IUnknown指针总是相同的。</li>
<li>若客户曾经获取过某个接口，那么它将总能获取此接口。</li>
<li>客户可以再次获取已经拥有的接口。</li>
<li>客户可以返回到起始找接口。</li>
<li>若能够从某个接口获取某特定接口，那么从任意接口都将可以获取此接口。</li>
</ul>
</li>
<li><p><strong>组件新版本的处理</strong></p>
<p>每一个接口都有一个唯一的接口标识符（IID），一般情况下，我们不会改变接口，但可以建立一个新接口并为之指定一个新的IID。当 <code>QueryInterface</code> 接收到对老IID的查询时，它将返回老的接口。而当它收到对新的IID的查询时，它将返回新的接口。就 <code>QueryInterface</code> 而言，一个IID就是一个接口。</p>
<p><strong>何时需要建立一个新版本</strong></p>
<p>当改变了下列条件中的任何一个时，就应给新接口指定新的ID：</p>
<ul>
<li>接口中函数的数目。</li>
<li>接口中函数的顺序。</li>
<li>某个函数的参数。</li>
<li>某个函数参数的顺序。</li>
<li>某个函数参数的类型。</li>
<li>函数可能的返回值。</li>
<li>函数返回值的类型。</li>
<li>函数参数的含义。</li>
<li>接口中函数的含义。</li>
</ul>
<p>总之，只要是所做的修改将会导致已有客户不能正常运行，就应为接口指定新的ID。<br>在建立了某个接口的新版本时，也应相应地修改其名称。COM关于新版本名称的约定是在老名称后面加上一个数字。</p>
</li>
</ul>
<hr>
<h2 id="AddRef及Release的使用规则"><a href="#AddRef及Release的使用规则" class="headerlink" title="AddRef及Release的使用规则"></a>AddRef及Release的使用规则</h2><h3 id="正确使用引用计数"><a href="#正确使用引用计数" class="headerlink" title="正确使用引用计数"></a>正确使用引用计数</h3><ol>
<li>在返回之前调用 <code>AddRef</code> 。对于那些返回接口指针的函数，在返回之前应该用相应的指针调用 <code>AddRef</code> 。这些函数包括 <code>QueryInterface</code> 及 <code>CreateInstance</code> 。这样当客户从这样的函数得到一个接口后，它将无需调用 <code>AddRef</code> 。</li>
<li>使用完接口之后调用 <code>Release</code> 。在使用完某个接口之后应调用此接口的 <code>Release</code> 函数。</li>
<li>在赋值之后调用 <code>AddRef</code> 。在将一个接口指针赋值给另外一个接口指针时，应调用 <code>AddRef</code> 。换句话说，在建立接口的另外一个引用之后应增加相应组件的引用计数。</li>
</ol>
<h3 id="AddRef和Release的实现"><a href="#AddRef和Release的实现" class="headerlink" title="AddRef和Release的实现"></a>AddRef和Release的实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ULONG __stdcall <span class="title">AddRef</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> InterlockedIncrement(&amp;m_cRef);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ULONG __stdcall <span class="title">Release</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (InterlockedDecrement(&amp;m_cRef) == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> m_cRef;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="引用计数规则"><a href="#引用计数规则" class="headerlink" title="引用计数规则"></a>引用计数规则</h3><p>另外要注意的是， <code>AddRef</code> 和 <code>Release</code> 的返回值没有什么意义，只是在程序调试中才可能会用得上。</p>
<p>在函数中，无需对存在于局部变量中的接口指针进行引用计数。因为局部变量的生命期同函数的生命期是一样的，因此也将包含在调用者的生命期内。但当从某个全局变量或向某个全局变量复制一个指针时，则需要对此指针进行引用计数，这是因为全局变量可以从任何函数中的任意地方被释放掉。</p>
<ol>
<li><p>输出参数规则</p>
<p> 输出参数指的是给函数的调用者传回一个值的函数参数。如：</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">QueryInterface</span><span class="params">(<span class="keyword">const</span> IID&amp;, <span class="keyword">void</span>**)</span></span>;</span><br></pre></td></tr></table></figure>

<p> 任何在输出参数中（或作为返回值）返回一个新的接口指针的函数都<strong>必须</strong>对此接口指针调用 <code>AddRef</code> 。</p>
</li>
<li><p>输入参数规则</p>
<p> 输入参数指的是给函数传递某个值的参数，在函数体中将会使用这个值，但却不会修改它或将其返回给调用者。如：</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span> <span class="params">(IX* pIX)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  pIX-&gt;Fx();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 对传入函数的接口指针，<strong>无需</strong>调用 <code>AddRef</code> 和 <code>Release</code> ，这是因为函数的生命期嵌套在调用者的生命期内。</p>
</li>
<li><p>输入-输出参数规则</p>
<p> 输入-输出参数同时具有输入参数及输出参数的特性。在函数体中可以使用输入-输出参数的值，然后可以对这些值进行修改并返回给调用者。<br> 在函数中，对于用输入-输出参数传递进来的接口指针，必须在给它赋另外一个接口指针值之前调用其 <code>Release</code> 。在函数返回之前，还必须对输出参数中所保存的接口指针调用 <code>AddRef</code> 。</p>
</li>
<li><p>局部变量规则</p>
<p> 对于局部复制的接口指针，由于它们只是在函数的生命期内才存在，因此无需调用 <code>AddRef</code> 和 <code>Release</code> 。这条规则实际上是输入参数规则的直接结果。</p>
</li>
<li><p>全局变量规则</p>
<p> 对于保存在全局变量中的接口指针，在将其传递给另外一个函数之前，必须调用其 <code>AddRef</code> 。由于此变量是全局性的，因此任何函数都可以通过调用其 <code>Release</code> 来终止其生命期。对于保存在成员变量中的接口指针，也应按此种方式进行处理。因为类中的任何成员函数都可以改变成员变量接口指针的状态。</p>
</li>
<li><p>不能确定时的规则</p>
<p> 对于任何不能确定的情形，都应调用 <code>AddRef</code> 和 <code>Release</code> 对。</p>
</li>
</ol>
<hr>
<h2 id="HRESULT值的查找"><a href="#HRESULT值的查找" class="headerlink" title="HRESULT值的查找"></a>HRESULT值的查找</h2><p>&lt;*WINERROR.H*&gt;中包含当前系统产生的所有COM（及OLE，现在被称作ActiveX）状态代码。  </p>
<p>但是，若某个HRESULT值具有FACILITY_WIN32设备代码，那么我们将会发现它并不在HRESULT值列表中。通常它是一个被映射成HRESULT值的Win32错误代码。为查明其含义，可查找低16位与之相同的Win32错误代码。<br>如：0x80070103，其中7就是设备代码FACILITY_WIN32。当在&lt;*WINERROR.H*&gt;中查找时，将会发现0x80070103并没有被列在HRESULT值中。为查明其含义，可将低16为从十六进制数转换成十进制数259，然后我们可以在Win32错误代码列表中找到它。</p>
<h3 id="使用FormatMessage函数显示标准错误信息"><a href="#使用FormatMessage函数显示标准错误信息" class="headerlink" title="使用FormatMessage函数显示标准错误信息"></a>使用FormatMessage函数显示标准错误信息</h3><p>为了显示标准COM（以及ActiveX和Win32，其中ActiveX的前身为OLE）错误消息，我们可以使用Win32 API中的 <code>FormatMessage</code> 函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ErrorMessage</span><span class="params">(LPCTSTR str, HRESULT hr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* pMsgBuf;</span><br><span class="line">    ::FormatMessage(</span><br><span class="line">        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        Hr,</span><br><span class="line">        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),</span><br><span class="line">        (LPTSTR)&amp;pMsgBuf,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// Display the string.</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str&lt;&lt;<span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Error(&quot;</span>&lt;&lt;hex&lt;&lt;hr&lt;&lt;<span class="string">&quot;): &quot;</span></span><br><span class="line">        &lt;&lt;(LPTSTR)pMsgBuf&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// Free the buffer.</span></span><br><span class="line">    LocalFree(pMsgBuf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="HRESULT值的使用"><a href="#HRESULT值的使用" class="headerlink" title="HRESULT值的使用"></a>HRESULT值的使用</h2><p>一个函数在各种情况下返回的状态代码通常包含多个成功代码及多个失败代码。<br>一般不能直接将HRESULT值同某个成功代码（如S_OK）进行比较，以决定某个函数是否成功，也不能直接将它同某个失败代码（如E_FAILED）进行比较，以决定函数调用是否失败。因此下面的代码是有问题的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HRESULT hr = CoCreateInstance(...);</span><br><span class="line"><span class="keyword">if</span> (hr == E_FAILED) <span class="comment">// Don&#x27;t do this!</span></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">hr = pI-&gt;QueryInterface(...);</span><br><span class="line"><span class="keyword">if</span> (hr == S_OK) <span class="comment">// Don&#x27;t do this!</span></span><br><span class="line">&#123;</span><br><span class="line">  pIX-&gt;Fx();</span><br><span class="line">  pIX-&gt;Release();</span><br><span class="line">&#125;</span><br><span class="line">pI-&gt;Release;</span><br></pre></td></tr></table></figure>

<p>为纠正上述代码中的错误，可以不将HRESULT值同S_OK或E_FAILED值直接进行比较，而使用SUCCEEDED及FAILED宏。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HRESULT hr = CoCreateInstance(...);</span><br><span class="line"><span class="keyword">if</span> (FAILED(hr))</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">hr = pI-&gt;QueryInterface(...);</span><br><span class="line"><span class="keyword">if</span> (SUCCEEDED(hr))</span><br><span class="line">&#123;</span><br><span class="line">  pIX-&gt;Fx();</span><br><span class="line">  pIX-&gt;Release();</span><br><span class="line">&#125;</span><br><span class="line">pI-&gt;Release;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="HRESULT用户自己代码的定义"><a href="#HRESULT用户自己代码的定义" class="headerlink" title="HRESULT用户自己代码的定义"></a>HRESULT用户自己代码的定义</h2><h3 id="定义HRESULT的规则"><a href="#定义HRESULT的规则" class="headerlink" title="定义HRESULT的规则"></a>定义HRESULT的规则</h3><p>下面给出关于定义自己的 <code>HRESULT</code> 的一些一般性规则：</p>
<ul>
<li>不要将 <code>0x0000</code> 及 <code>0x01FF</code> 范围内的值作为返回代码。这些值是为COM所定义的 <code>FACILITY_ITF</code> 代码而保留的。只有遵循这一股则，才不致使用户自己定义的代码同COM所定义的代码相混淆。</li>
<li>不要传播 <code>FACILITY_ITF</code> 错误代码。</li>
<li>尽可能地使用通用的COM成功及失败代码。</li>
<li>避免定义自己的 <code>HRESULT</code> ，而可以在函数中使用一个输出参数。</li>
</ul>
<h3 id="使用MAKE-HRESULT自定义HRESULT值"><a href="#使用MAKE-HRESULT自定义HRESULT值" class="headerlink" title="使用MAKE_HRESULT自定义HRESULT值"></a>使用MAKE_HRESULT自定义HRESULT值</h3><p>使用 <code>MAKE_HRESULT</code> 宏来定义一个 <code>HRESULT</code> 值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, <span class="number">100</span>);</span><br><span class="line">MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_ITF, <span class="number">101</span>);</span><br></pre></td></tr></table></figure>

<p>对于自己定义的返回代码的命名，有一个约定是在其名称前面加上组件或接口的名称。如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AIRPLANE_E_LANDINGWITHGEARUP</span><br><span class="line">HELICOPTER_S_ROTORRPMGREEN</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="GUID的声明和定义"><a href="#GUID的声明和定义" class="headerlink" title="GUID的声明和定义"></a>GUID的声明和定义</h2><p>在&lt;*IFace.h*&gt;中声明 <code>IID_IX</code> ，在&lt;*Guids.cpp*&gt;中定义 <code>IID_IX</code> ：</p>
<p>为了方便，可以在&lt;*IFace.h*&gt;中使用 <code>DEFINE_GUID</code> 宏来声明，可直接使用工具<em>GuidGen.exe</em>来生成，选择第二种格式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &#123;F03AC6A1-755A-4fc2-A845-FAAAF1DEA1E1&#125;</span></span><br><span class="line">DEFINE_GUID(&lt;&lt;name&gt;&gt;,</span><br><span class="line"><span class="number">0xf03ac6a1</span>, <span class="number">0x755a</span>, <span class="number">0x4fc2</span>, <span class="number">0xa8</span>, <span class="number">0x45</span>, <span class="number">0xfa</span>, <span class="number">0xaa</span>, <span class="number">0xf1</span>, <span class="number">0xde</span>, <span class="number">0xa1</span>, <span class="number">0xe1</span>);</span><br><span class="line"><span class="comment">// 用IID_IX替换&lt;&lt;name&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<p>而在&lt;*Guids.cpp*&gt;中只需包含如下代码即可：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ObjBase.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;InitGuid.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;IFace.h&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>在组件实现文件&lt;*Cmpnt.cpp*&gt;中包含如下代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ObjBase.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;IFace.h&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>另外在客户端也要导入&lt;*IFace.h*&gt;和&lt;*Guids.cpp*&gt;文件</p>
<hr>
<hr>
<h2 id="Windows注册表明细"><a href="#Windows注册表明细" class="headerlink" title="Windows注册表明细"></a>Windows注册表明细</h2><p>组件用<em>CLSID</em>作为索引在Windows的注册表中发布DLL文件名称。 <code>CoCreateInstance</code> 用<em>CLSID</em>作为关键字在注册表中查找此文件名称。</p>
<blockquote>
<p>COM只使用了注册表的一个分支：<em>HKEY_CLASSES_ROOT</em>。在此键之下，可以看到有一个<em>CLSID</em>键。在<em>CLSID</em>键之下列有系统中安装的所有组件的<em>CLSID</em>。对于每一个<em>CLSID</em>键，我们现在关心的只是它的一个子键 <code>InprocServer32</code> ，此子键的默认值是组件的DLL文件名称。</p>
</blockquote>
<ul>
<li><p><strong>其他细节</strong>：</p>
<p>在<em>HKEY_CLASSES_ROOT</em>的开头，列出的将是各种应用程序所注册的文件扩展名。在扩展名之后，可以看到许多其他的名字。此类名字的大多数被称作<em>ProgID</em>，表示是程序定义的标识符。某些名称表示的不是<em>ProgID</em>而是一些特殊的键，如<em>CLSID</em>键。这些键可以将一个<em>GUID</em>映射为其他一些信息，如文件名称。如下所列均为一些特殊的键。</p>
<ul>
<li><strong>APPID</strong>——此键下的子键的作用是将某个<em>APPID</em>（应用ID）映射成某个远程服务器名称。分布式COM（DCOM）将用到此键。</li>
<li><strong>组件类别</strong>——注册表的这一分支可以将<em>CATID</em>（组件类别ID）映射成某个特定的组件类别。</li>
<li><strong>Interface</strong>——此键用于将<em>IID</em>映射成与某个接口相关的信息。这些信息主要用于在跨越进程边界使用接口时的情况。</li>
<li><strong>Licenses</strong>——<em>Licenses</em>保存的是授权使用COM组件的一些许可信息。</li>
<li><strong>TypeLib</strong>——类型库所保存的是关于接口成员函数所用参数的信息，另外还有其他一些信息。此键可以将一个<em>LIBID</em>映射成存储类型库的文件名称。</li>
</ul>
</li>
<li><p><strong>ProgID</strong>：</p>
<p>所谓<em>ProgID</em>指的是程序员给某个<em>CLSID</em>指定的一个友好的名称。<br>根据约定，<em>ProgID</em>具有如下的格式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Program&gt;.&lt;Component&gt;.&lt;Version&gt;</span><br></pre></td></tr></table></figure>

<p>另外组件还有一个与版本号无关的<em>ProgID</em>，此<em>ProgID</em>被映射成所安装的最新版本的组件。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Program&gt;.&lt;Component&gt;</span><br></pre></td></tr></table></figure>

<p>从<em>ProgID</em>到<em>CLSID</em>的转换：COM库为此提供了两个函数 <code>CLSIDFromProgID</code> 和 <code>ProgIDFromCLSID</code> ，以完成所需的注册表处理。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CLSID clsid;</span><br><span class="line">CLSIDFromProgID(L”Helpcopter.TralRotor”, &amp;clsid);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h2 id="组件自注册"><a href="#组件自注册" class="headerlink" title="组件自注册"></a>组件自注册</h2><p>从DLL中引出如下两个函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">STDAPI <span class="title">DllRegisterServer</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">STDAPI <span class="title">DllUnregisterServer</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中， <code>STDAPI</code> 在&lt;*ObjBase.h*&gt;中被定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STDAPI EXTERN_C HRESULT STDAPICALLTYPE</span></span><br></pre></td></tr></table></figure>

<p>展开后它将是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> “C” HRESULT __stdcall</span><br></pre></td></tr></table></figure>

<p>只需用 <code>LoadLibrary</code> 装载相应的DLL，然后用 <code>GetProcAddress</code> 获取此函数的地址，再调用 <code>DllRegisterServer</code> 函数即可。</p>
<blockquote>
<p><code>DllRegisterServer</code> 的实现实际上是通过直接调用注册表函数来完成的。为注册某个组件或注销某个组件的注册，只需要用到其中的6个函数：</p>
<ul>
<li>RegOpenKeyEx</li>
<li>RegCreateKeyEx</li>
<li>RegSetValueEx</li>
<li>RegEnumKeyEx</li>
<li>RegDeleteKey</li>
<li>RegCloseKey</li>
</ul>
<p>使用这些函数，需要在源文件中包含&lt;*WinReg.h*&gt;或&lt;*Windows.h*&gt;头文件，并链接<em>AdvApi32.lib</em>。</p>
</blockquote>
<hr>
<h2 id="COM库函数"><a href="#COM库函数" class="headerlink" title="COM库函数"></a>COM库函数</h2><p>在使用COM库中的其他函数之前，进程必须先调用 <code>CoInitialize</code> 来初始化COM库。当进程不再需要使用COM库函数时，必须调用 <code>CoUninitialize</code> 。这两个函数的原型定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">CoInitialize</span><span class="params">(<span class="keyword">void</span> reserved)</span></span>;  <span class="comment">//Argument must be NULL</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CoUninitialize</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>OLE是建立在COM基础之上的，它增加了对类型库、剪贴板、拖放、ActiveX文档、自动化以及ActiveX控件的支持。在需要使用这些特性是，我们应调用 <code>OleInitialize</code> 及 <code>OleUninitialize</code> 。</p>
<hr>
<h2 id="组件中内存管理"><a href="#组件中内存管理" class="headerlink" title="组件中内存管理"></a>组件中内存管理</h2><p>我们可以通过一个接口来使用任务内存分配器，在这种情况下，此接口为 <code>IMalloc</code> ，它可以由 <code>CoGetMalloc</code> 返回。为分配一块内存，我们可以使用 <code>IMalloc::Alloc</code> ；而由 <code>IMalloc::Alloc</code> 所分配的内存的释放操作可以由 <code>IMalloc::Free</code> 完成。但大多数情况下，调用 <code>CoGetMalloc</code> 来获取接口指针，然后使用此指针来调用某个函数，再施放此指针是一个比较繁琐的过程。为此，COM库实现了一些方便的辅助函数，如 <code>CoTaskMemAlloc</code> 和 <code>CoTaskMemFree</code> ：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">CoTaskMemAlloc</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    ULONG cb    <span class="comment">// Size in bytes of block to be allocated</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CoTaskMemFree</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span>* pv    <span class="comment">//Pointer to memory block to be freed</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="将字符串转换成GUID"><a href="#将字符串转换成GUID" class="headerlink" title="将字符串转换成GUID"></a>将字符串转换成GUID</h2><p><code>StringFromGUID2</code> 可以将某个<em>GUID</em>转换成一个字符串：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wchar_t</span> szCLSID[<span class="number">39</span>];</span><br><span class="line"><span class="keyword">int</span> r = ::StringFromGUID2(CLSID_Component1, szCLSID, <span class="number">39</span>);</span><br></pre></td></tr></table></figure>

<p>传给 <code>StringFromGUID2</code> 的参数是一个<em>Unicode</em>串。在非<em>Unicode</em>的系统中，需要将结果进一步转换为单字节字符（<em>char</em>）。为此可以使用<em>ANSI</em>的 <code>wcstombs</code> 函数，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _UNICODE</span></span><br><span class="line"><span class="comment">// Convert from widechar to non-wide….</span></span><br><span class="line"><span class="keyword">char</span> szCLSID_single[<span class="number">39</span>];</span><br><span class="line">wcstombs(szCLSID_single, szCLSID, <span class="number">39</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>其他一些可以完成类似工作的函数如下表所列。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>StringFromCLSID</td>
<td>将CLSID转换成文本串</td>
</tr>
<tr>
<td>StringFromIID</td>
<td>将IID转换成文本串</td>
</tr>
<tr>
<td>StringFromGUID2</td>
<td>将CLSID转换成文本串。此串将被存放在调用者所分配的缓冲区中</td>
</tr>
<tr>
<td>CLSIDFromString</td>
<td>将一个文本串转换成CLSID</td>
</tr>
<tr>
<td>IIDFromString</td>
<td>讲一个文本串转换成IID</td>
</tr>
</tbody></table>
<p>上表所列的某些函数需要用到任务内存分配器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wchar_t</span>* <span class="built_in">string</span></span><br><span class="line"><span class="comment">// Get String from CLSID</span></span><br><span class="line">::StringFromCLSID(CLSID_Component1, &amp;<span class="built_in">string</span>);</span><br><span class="line"><span class="comment">// Use string</span></span><br><span class="line">︙</span><br><span class="line"><span class="comment">// Free string</span></span><br><span class="line">::CoTaskMemFree(<span class="built_in">string</span>);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="类厂"><a href="#类厂" class="headerlink" title="类厂"></a>类厂</h2><h3 id="CoCreateInstance"><a href="#CoCreateInstance" class="headerlink" title="CoCreateInstance"></a>CoCreateInstance</h3><p><code>CoCreateInstance</code> 的声明如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HRESULT __stdcall <span class="title">CoCreateInstance</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> CLSID&amp; clsid,</span></span></span><br><span class="line"><span class="function"><span class="params">    IUnknown* pIUnknownOuter,   <span class="comment">// Outer Component</span></span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD dwClsContext,         <span class="comment">// Server context</span></span></span></span><br><span class="line"><span class="function"><span class="params">    Const IID&amp; iid,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span>** ppv</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>CoCreateInstance</code> 的用法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create Component.</span></span><br><span class="line">IX* pIX = <span class="literal">NULL</span>;</span><br><span class="line">HRESULT hr = ::CoCreateInstance(</span><br><span class="line">    CLSID_Component1,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    CLSCTX_INPROC_SERVER,</span><br><span class="line">    IID_IX,</span><br><span class="line">    (<span class="keyword">void</span>**)&amp;pIX</span><br><span class="line">);</span><br><span class="line">If (SUCCEEDED(hr))</span><br><span class="line">&#123;</span><br><span class="line">    pIX-&gt;Fx();</span><br><span class="line">    pIX-&gt;Release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类环境"><a href="#类环境" class="headerlink" title="类环境"></a>类环境</h3><p><code>CoCreateInstance</code> 的第三个参数 <code>dwClsContext</code> 可以控制所创建的组件是在与客户相同的进程中运行，还是在不同的进程中运行，或者是在另外一台机器上运行。此参数的值可以是如下所列各值的组合。</p>
<ul>
<li><strong>CLSCTX_INPROC_SERVER</strong><br>  客户希望创建在同一进程中运行的组件。为能够同客户在同一进程中运行，组件必须是在DLL中实现的。</li>
<li><strong>CLSCTX_INPROC_HANDLER</strong><br>  客户希望创建进程内控制器。一个进程内控制器实际上是一个只实现了某个组件的一部分的进程内组件。该组件的其他部分将由本地或远程服务器上的某个进程外组件实现。</li>
<li><strong>CLSCTX_LOCAL_SERVER</strong><br>  客户希望创建一个在同一台机器上的另外一个进程中运行的组件。本地服务程序是有EXE实现的。</li>
<li><strong>CLSCTX_REMOTE_SERVER</strong><br>  客户希望创建一个在远程机器上运行的组件。此标志需要分布式COM的支持。</li>
</ul>
<h3 id="CoGetClassObject"><a href="#CoGetClassObject" class="headerlink" title="CoGetClassObject"></a>CoGetClassObject</h3><p><code>CoCreateInstance</code> 实际上并没有直接创建COM组件，而是创建了一个被称作是类厂的组件。而所需的组件正是由此类厂创建的。类厂组件的唯一功能就是创建其他的组件。更精确地讲，某个特定的类厂将创建只同某个特定的<em>CLSID</em>相对应的组件。客户可以通过类厂所支持的接口来对类厂创建组件的过程加以控制。创建组件的标准接口是<code>IClassFactory</code> ，用 <code>CoCreateInstance</code> 创建的组件实际上是通过 <code>IClassFactory</code> 接口创建的。</p>
<p><code>CoCreateInstance</code> 将接受一个<em>CLSID</em>作为参数并返回指向所创建的组件中某个接口的指针。为创建同某个<em>CLSID</em>相对应的类厂，需要一个与 <code>CoCreateInstance</code> 等价的、也可接收一个<em>CLSID</em>作为参数并返回相应类厂中某个接口指针的函数。这个函数就是COM库中的 <code>CoGetClassObject</code> 。</p>
<p>此函数的声明如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HRESULT __stdcall <span class="title">CoGetClassObject</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> CLSID&amp; clsid,</span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD dwClsContext,</span></span></span><br><span class="line"><span class="function"><span class="params">    COSERVERINFO* pServerInfo,    <span class="comment">//Reserved for DCOM</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> IID&amp; iid,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span>** ppv</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>CoGetClassObject</code> 返回的是指向所需组件的类厂而不是指向组件本身的一个指针。客户可以用 <code>CoGetClassObject</code> 所返回的指针来创建所需的组件。这个指针通常是 <code>IClassFactory</code> 指针。</p>
<h3 id="IClssFactory"><a href="#IClssFactory" class="headerlink" title="IClssFactory"></a>IClssFactory</h3><p>类厂所支持的用于创建组件的标准接口是 <code>IClassFactory</code> 。大多数组件均可使用 <code>IClassFactory</code> 接口来创建。此接口的声明如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface IClassFatory : IUnknown</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">HRESULT __stdcall <span class="title">CreateInstance</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        IUnknown* pUnknownOuter,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> IID&amp; iid,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">void</span>** ppv</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>;</span><br><span class="line">    <span class="function">HRESULT __stdcall <span class="title">LockServer</span><span class="params">(BOOL bLock)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>IClassFactory</code> 有两个成员函数。第一个成员函数为 <code>CreateInstance</code> ，第二个成员函数为 <code>LockServer</code> 。</p>
<p><code>IClassFactory::CreateInstace</code> 的第一参数 <code>pUnknownOuter</code> 为只想某个 <code>IUnknown</code> 接口的指针，同传给 <code>CoCreateInstance</code> 的 <code>IUnknown</code> 指针是相同的，用于聚合组件。其余两个参数同传给 <code>QueryInterface</code> 的参数是相同的。使用这两个参数，客户可以在创建组件的同时请求此组件中某个接口的指针。这样可以为客户省去一次函数的调用。当组件在远程机器上运行时，它还可以省去一次来回网络传输的开销。</p>
<h3 id="CoCreateInstance与CoGetClassObject的比较"><a href="#CoCreateInstance与CoGetClassObject的比较" class="headerlink" title="CoCreateInstance与CoGetClassObject的比较"></a>CoCreateInstance与CoGetClassObject的比较</h3><p>在每次创建组件时，先创建相应的类厂，然后用所获取的 <code>IClassFactory</code> 指针来创建所需的组件，这个过程显然比直接调用 <code>CoCreateInstance</code> 来创建所需的组件要复杂一些。这也正是为什么大多数组件都使用 <code>CoCreateInstance</code> 的原因。但前面提到过， <code>CoCreateInstance</code> 实际上是通过 <code>CoGetClassObject</code> 实现的。下面的代码表示了如何用 <code>CoGetClassObject</code> 来实现 <code>CoCreateInstance</code> ：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">CoCreateInstance</span><span class="params">(<span class="keyword">const</span> CLSID&amp; clsid, IUnknown* pUnknownOuter, DOWRD dwClsContext, <span class="keyword">const</span> IID&amp; iid, <span class="keyword">void</span>** ppv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//Set the out parametet to NULL.</span></span><br><span class="line">    *ppv = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//Create the class factory and get an IClassFactory interface pointer.</span></span><br><span class="line">    IClassFactory* pIFactory = <span class="literal">NULL</span>;</span><br><span class="line">    HRESULT hr = CoGetClassObject(</span><br><span class="line">        clsid,</span><br><span class="line">        dwClsContext,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        IID_IClassFactory,</span><br><span class="line">        (<span class="keyword">void</span>**)&amp;pIFactory</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (SUCCEEDED(hr))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Create the component.</span></span><br><span class="line">        hr = pIFactory-&gt;CreateInstance(pUnknownOuter, iid, ppv);</span><br><span class="line">        <span class="comment">//Release the class factory.</span></span><br><span class="line">        pIFactory-&gt;Release();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大多数情况下，组件的创建均可使用 <code>CoCreateInstance</code> 而不使用 <code>CoGetClassObject</code> 。但是在如下两种情况下应使用 <code>CoGetClassObject</code> 而不应使用 <code>CoCreateInstance</code> 。</p>
<blockquote>
<p>第一种情况是，若想用不同于 <code>IClassFactory</code> 的某个创建接口来创建组件，则必须使用 <code>CoGetClassObject</code> 。因此如果想使用 <code>IClassFactory2</code> 来创建组件的话，就应使用 <code>CoGetClassObject</code> 。</p>
<blockquote>
<p><strong>IClassFactory2</strong><br>除了 <code>IClassFactory</code> 之外，Microsoft还定义了另外一个用于创建组件的接口 <code>IClassFactory2</code> 。此接口在 <code>IClassFactory</code> 的基础上增加了许可或权限功能。在类厂创建所需的组件之前，客户必须通过 <code>IClassFactory2</code> 给类厂提供正确的密钥或许可。通过使用 <code>IClassFactory2</code> ，类厂可以保证客户只能获得它能合法访问的组件，并具有对此组件的访问授权。  </p>
</blockquote>
<p>第二种情况是，若需创建同一组件的多个实例，那么使用 <code>CoGetClassObject</code> 可以获得更高的效率。因为这时只需创建相应的类厂一次，而 <code>CoCreateInstance</code> 需为每一个实例分别创建并释放相应的类厂。</p>
<p>另外 <code>CoGetClassObject</code> 使得客户可以对组件的创建过程进行更多的控制。</p>
</blockquote>
<h3 id="类厂的若干特性"><a href="#类厂的若干特性" class="headerlink" title="类厂的若干特性"></a>类厂的若干特性</h3><ul>
<li>首先，类厂的一个实例将只能创建同某个<em>CLSID</em>相对应的组件。这一点从 <code>CoGetClassObject</code> 将接收一个<em>CLSID</em>而 <code>IClassFactory::CreateInstance</code> 却不接受此参数可以看出来。</li>
<li>其次，与某个特定<em>CLSID</em>相对应的类厂将是由实现组件的开发人员实现的。大多数情况下，类厂组件包含在与它所创建的组件相同的DLL中。</li>
</ul>
<h3 id="DllGetClassObject的使用"><a href="#DllGetClassObject的使用" class="headerlink" title="DllGetClassObject的使用"></a>DllGetClassObject的使用</h3><p><code>CallCreateInstance</code> 调用了DLL中的 <code>CreateInstance</code> 来创建所需的组件，类似地 <code>CoGetClassObject</code> 需要DLL中的一个特定函数来创建组件的类厂。此函数的名称为 <code>DllGetClassObject</code> 。 <code>CoGetClassObject</code> 将调用此函数，由它创建类厂。</p>
<p><code>DllGetClassObject</code> 的声明如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">STDAPI <span class="title">DllGetClassObject</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> CLSID&amp; clsid,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> IID&amp; iid,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span>** ppv</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>第一个参数为类厂将要创建的组件的<em>CLSID</em>；第二个参数为类厂中客户希望得到的接口ID。而接口的指针将被返回在最后一个参数中。</p>
<p>将<em>CLSID</em>传给 <code>DllGetClassObject</code> 是非常重要的，这使得一个DLL可以支持任意多个组件，因为 <code>DllGetClassObject</code> 可以用<em>CLSID</em>来选择合适的类厂。</p>
<h3 id="DLL的卸载"><a href="#DLL的卸载" class="headerlink" title="DLL的卸载"></a>DLL的卸载</h3><h4 id="DllCanUnloadNow的使用"><a href="#DllCanUnloadNow的使用" class="headerlink" title="DllCanUnloadNow的使用"></a>DllCanUnloadNow的使用</h4><p>客户调用 <code>CoUninitialize</code> 组件函数来卸载组件，该函数会调用 <code>DllCanUnloadNow</code> 来询问DLL是否可以被卸载掉。DLL为了确定它是否仍在提供对组件的服务，将维护一个关于组件的计数值，通过 <code>IClassFactory::CreateInstance</code> 或组件的构造函数可以将该值增大，而组件的析构函数可以将此值减小。当该值为零时， <code>DllCanUnloadNow</code> 将给出肯定的回答。</p>
<h4 id="LockServer"><a href="#LockServer" class="headerlink" title="LockServer"></a>LockServer</h4><p>上述的方法统计的只是DLL提供的组件，而不包括DLL提供的那些类厂。但这些类厂可能一直是被用着的。因此在统计组件时，同时也统计类厂将更为合理。对于进程内组件服务程序，对类厂进行统计是可以的。</p>
<hr>

        
      </div>
    </div>

  
    </div>
  






          <div class="main-footer">
  
    © 2020 Hexo - Powered by <a href="http://hexo.io" target="_blank">Hexo</a> - Theme <a href="https://github.com/denjones/hexo-theme-chan" target="_blank">Chan</a>
  
</div>

      
        </div>
      
    </div>
  </div>
  
<script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>


  
<link rel="stylesheet" href="/PhotoSwipe/photoswipe.css">

  
<link rel="stylesheet" href="/PhotoSwipe/default-skin/default-skin.css">


  <!-- Root element of PhotoSwipe. Must have class pswp. -->
  <div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe.
             It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

      <!-- Container that holds slides.
                PhotoSwipe keeps only 3 of them in the DOM to save memory.
                Don't modify these 3 pswp__item elements, data is added later on. -->
      <div class="pswp__container">
        <div class="pswp__item"></div>
        <div class="pswp__item"></div>
        <div class="pswp__item"></div>
      </div>

      <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
      <div class="pswp__ui pswp__ui--hidden">

        <div class="pswp__top-bar">

          <!--  Controls are self-explanatory. Order can be changed. -->

          <div class="pswp__counter"></div>

          <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

          <button class="pswp__button pswp__button--share" title="Share"></button>

          <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

          <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

          <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
          <!-- element will get class pswp__preloader--active when preloader is running -->
          <div class="pswp__preloader">
            <div class="pswp__preloader__icn">
              <div class="pswp__preloader__cut">
                <div class="pswp__preloader__donut"></div>
              </div>
            </div>
          </div>
        </div>

        <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
          <div class="pswp__share-tooltip"></div>
        </div>

        <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>

        <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button>

        <div class="pswp__caption">
          <div class="pswp__caption__center"></div>
        </div>
      </div>
    </div>
  </div>

  
<script src="/PhotoSwipe/photoswipe.js"></script>

  
<script src="/PhotoSwipe/photoswipe-ui-default.js"></script>




<script src="/perfect-scrollbar/js/min/perfect-scrollbar.min.js"></script>


<script src="/scripts/main.js"></script>


<script src="/scripts/copycode.js"></script>


</body>
</html>
